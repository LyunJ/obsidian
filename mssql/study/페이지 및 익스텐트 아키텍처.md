# 페이지 및 익스텐트
SQL Server의 기본 데이터 스토리지 단위는 페이지이다. 데이터베이스의 데이터 파일(.mdf 또는 .ndf)에 할당된 디스크 공간은 논리적으로 0에서 n까지 연속적으로 번호가 매겨진 페이지로 나뉜다. 디스크 I/O 작업은 페이지 수준에서 수행된다. 즉, SQL Server가 전체 데이터 페이지를 읽거나 쓴다.

익스텐트는 실제로 연속하는 8페이지를 모은 것으로 페이지를 효율적으로 관리하는 데 사용된다. 모든 페이지는 익스텐트가 구성된다.


## 페이지

모든 페이지 크기는 8KB이다.

### 페이지 종류
- 데이터 페이지
	- 행의 텍스트가 ON으로 설정된 경우 **text**, **ntext**, **image**, **nvarchar(max)**, **varchar(max)**, **varbinary(max)** 및 **xml** 데이터를 제외한 모든 데이터가 있는 데이터 행.
- 인덱스 페이지
	- 데이터가 있는 위치에 대한 인덱스 참조가 포함
- 텍스트/이미지
	- 큰 개체 데이터 형식: **text**, **ntext**, **image**, **nvarchar(max)**, **varchar(max)**, **varbinary(max)** 및 **xml** 데이터. 
	- 데이터 행이 varchar, **nvarchar**, **varbinary** 및 **sql_variant** 8KB를 초과하는 경우의 가변 길이 열.
- 전역 할당 맵(GAM) & 공유 전역 할당 맵(SGAM)
	- 익스텐트가 할당되었는지 여부에 대한 정보
- 페이지의 사용 가능한 공간(PFS)
	- 페이지 할당 및 페이지의 사용 가능한 공간에 대한 정보
- 인덱스 할당 맵(IAM)
	- 테이블 또는 인덱스에서 할당 단위당 사용하는 익스텐트에 대한 정보
- BCM(대량 변경 맵)
	- 마지막 BACKUP LOG 문 이후에 할당 단위당 대량 작업에 의해 수정된 익스텐트에 대한 정보
- DCM(차등 변경 맵)
	- 마지막 BACKUP DATABASE 문 이후에 할당 단위당 변경된 익스텐트에 대한 정보

> 로그 파일에는 페이지가 없다. 고정 크기가 없는 일련의 로그 레코드를 포함한다.

각 페이지는 96바이트 header로 시작하는데 이 머리글은 페이지에 대한 시스템 정보를 저장하는 데 사용된다. 페이지 번호, 페이지 유형, 해당 페이지의 사용 가능한 공간 크기 그리고 해당 페이지를 소유하고 있는 개체의 할당 단위 ID와 같은 정보를 저장한다.

데이터 행은 header 바로 다음에 시작하여 페이지에 직렬로 저장된다. 행 오프셋 테이블은 페이지 끝에서 시작하는데 각 행 오프셋 테이블에는 해당 페이지에 있는 각 행에 대한 항목이 하나씩 있다. 각 행 오프셋 항목은 행의 첫 번째 바이트가 페이지 시작부터 얼마나 멀리 떨어져 있는지 저장한다. 따라서 행 오프셋 테이블의 함수는 SQL Server 페이지에서 행을 빠르게 찾을 수 있도록 하는 것이다. 행 오프셋 테이블의 항목 순서는 페이지의 행 순서의 역순이다.

![[Pasted image 20230503172945.png]]

### 큰 행 지원
행은 페이지에 걸쳐있지 않다. 그러나 행의 일부가 행의 페이지에서 이동할 수 있으므로 행이 매우 클 수 있다. 페이지의 단일 행에 포함된 최대 데이터 및 오버헤드 양은 8060바이트입니다. 텍스트/이미지 페이지 형식에 저장된 데이터는 포함되지 않는다.

이 제한은 varchar, nvarchar, varbinary 또는 slq_zariant열을 포함하는 테이블에 대해 완화된다. 테이블에 있는 모든 고정 및 변수 열의 전체 행 크기가 8060바이트 한계를 초과하면 SQL Server는 하나 이상의 가변 길이 열을 가장 너비가 넓은 열부터 시작하여 ROW_OVERFLOW_DATA 할당 단위에 있는 페이지로 동적으로 옮긴다.

삽입 또는 업데이트 작업으로 행의 전체 크기가 8060바이트 한계를 초과하면 이러한 작업이 수행됩니다. 열이 ROW_OVERFLOW_DATA 할당 단위의 페이지로 이동하면 IN_ROW_DATA 할당 단위에 있는 원래 페이지의 24바이트 포인터가 그대로 유지됩니다. 후속 작업으로 행 크기가 줄면 SQL Server가 동적으로 열을 다시 원래 데이터 페이지로 이동합니다.


### 행 오버플로 고려 사항
행 오버플로가 발생했을 시 ROW_OVERFLOW_DATA 할당 단위의 페이지로 동적으로 이동할 수 있다.
- 업데이터 작업에 따라 레코드가 짧아지는 경우 해당 레코드는 IN_ROW_DATA 할당 단위에 있는 원래 페이지로 다시 이동할 수도 있다.
  
  행 오버플로 데이터가 포함된 큰 레코드에 대한 작업을 수행하면 해당 레코드가 비동기적으로 처리되지 않고 동기적으로 처리 되기 때문에 처리 시간이 느려진다.
  
  행 오버플로 데이터가 있는 다수의 행에서 쿼리가 자주 수행될 가능성이 높은 경우에는 일부 열이 다른 테이블로 이동하도록 테이블을 정규화해야한다. 
- 개별 열의 길이는 8000 바이트 이내여야하고, 이 열들이 결합되는 경우에만 테이블의 8060바이트의 행 제한을 초과할 수 있다.
- 클러스터형 인덱스의 인덱스 키는 ROW_OVERFLOW_DATA 할당 단윙에 기존 데이터가 있는 varchar 열을 포함할 수 없다.
- 행 오버플로 데이터가 있는 열을 비클러스터형 인덱스의 키 열이나 키가 아닌 열로 포함할 수 있다.

## Extents
익스텐트는 공간 관리의 기본 단위이다. 하나의 익스텐트는 실제로 연속하는 8페이지 또는 64KB이다. 즉, SQL Server 데이터베이스에는 메가바이트당 16개의 익스텐트가 있다.

SQL Server에는 다음과 같이 두 가지 유형의 익스텐트가 있다.
- 균일 익스텐트는 단일 개체가 소유한다. 또한 익스텐트의 전체 8페이지는 소유하는 개체만 사용할 수 있다.
- 혼합 익스텐트는 최대 8개의 개체가 공유할 수 있다. 익스텐트의 8페이지를 각각 다른 개체가 소유할 수 있다.

![균일하고 혼합된 익스텐트 표시 다이어그램](https://learn.microsoft.com/ko-kr/sql/relational-databases/media/pages-and-extents-architecture-guide/extents.svg?view=sql-server-ver16)

SQL Server 2016 부터는 사용자 데이터베이스의 대부분의 할당에 대한 기본값이며 tempdb IAM 체인의 처음 8페이지에 속하는 할당을 제외하고 균일한 익스텐트를 사용하는 것이다. msdb 및 model 데이터베이스에 대한 master 할당은 여전히 이전 동작을 유지한다. 

SQL Server 2019부터 sys.dm_db_page_info 시스템 함수를 사용하여 DBCC PAGE를 대체할 수 있다.

# 익스텐트 할당 및 사용 가능한 공간 관리
익스텐트 할당을 관리하고 빈 공간을 추적하는 SQL Server 데이터 구조는 비교적 단순합니다. 다음과 같은 이점이 있다.
- 빈 공간 정보는 빽빽하게 묶여 있으므로 이 정보를 포함하는 페이지의 수는 비교적 적다.
- 대부분의 할당 정보는 함께 연결되지 않는다. 유지 관리가 간편하다.

## 익스텐트 할당 관리
SQL Server는 다음의 두 가지 형식의 할당 맵을 사용하여 익스텐트의 할당을 기록한다
- 전역 할당 맵(GAM)
  GAM 페이지는 어떤 익스텐트가 할당되었는지 기록한다. 각 GAM은 64000개의 익스텐트 또는 거의 4GB의 데이터를 처리한다. GAM은 각 익스텐트 간격에 대해 1비트이다. 비트 1이면 익스텐트 사용이 해제되고 비트가 0이면 익스텐트가 할당된다.
- 공유 전역 할당 맵(SGAM)
  SGAM 페이지는 어떤 익스텐트가 현재 혼합 익스텐트로 사용되고 있는지와 적어도 하나 이상의 사용되지 않은 페이지를 가지는지 기록한다. 

## 사용 가능한 공간 추적
PFS(Page Free Space) 페이지는 개별 페이지의 할당 여부 및 각 페이지에 있는 빈 공간의 양과 같은 페이지의 할당 상태를 기록한다. PFS는 각 페이지에 대해 1바이트를 가지며, 페이지가 할당되었는지 여부를 기록한다.

개체에 익스텐트가 할당된 후에는 데이터베이스 엔진에서 PFS 페이지를 사용하여 익스텐트의 할당된 페이지 도는 빈 페이지를 기록한다. 

# 개체에서 사용하는 공간 관리
IAM(Index Allocation Map) 페이지는 할당 단위에 사용되는 데이터베이스 파일의 4GB 부분에 익스텐트를 매핑한다. 할당 단위의 유형은 다음 3가지가 있다.

- IN_ROW_DATA : 힙 또는 인덱스의 파티션을 포함한다
- LOB_DATA : xml, varbinary(max) 및 varchar(max)와 같은 LOB 데이터 형식을 보유한다
- ROW_OVERFLOW_DATA : varchar, nvarchar, varbinary 또는 8060 바이트 행 크기 제한을 초과하는 sql_variant 열에 저장된 가변 길이 데이터를 보유한다

힙 또는 인덱스의 각 파티션에는 적어도 하나의 IN_ROW_DATA 할당 단위가 있다. 또한 힙 또는 인덱스 스키마에 따라 LOB_DATA 또는 ROW_OVERFLOW_DATA 할당 단위도 포함될 수 있다.

IAM 페이지는 파일에서 4GB 범위를 처리하며 이는 GAM 또는 SGAM 페이지와 동일하다. 할당 단위에 하나 이상의 파일에서 매핑된 익스텐트가 포함되어 있거나 4GB를 넘는 파일 범위가 포함되어 있으면 하나의 IAM 체인에 여러 IAM 페이지가 연결된다. 따라서 각 할당 단위에는 익스텐트가 매핑된 각 파일에 대해 하나 이상의 IAM 페이지가 포함된다. 또한 할당 단위에 할당된 파일의 익스텐트 범위가 단일 IAM 페이지가 기록할 수 있는 범위를 초과하는 경우 파일에 IAM 페이지가 두 개 이상 있을 수 있다.

데이터베이스 엔진이 새 행을 삽입해야 하고 현재 페이지에서 사용할 수 있는 공간이 없는 경우 IAM 및 PFS 페이지를 사용하여 할당할 페이지를 찾거나 힙 또는 텍스트 /이미지 페이지의 경우 행을 저장할 충분한 공간이 있는 페이지를 찾는다.


# 수정된 익스텐트 추적
SQL Server는 두 개의 내부 데이터 구조를 사용하여 대량 복사 작업으로 수정된 익스텐트와 마지막 전체 백업 이후 수정된 익스텐트를 추적한다. 이 두 데이터 구조를 사용하면 차등 백업의 속도가 크게 향상된다. 이러한 구조체는 각 비트가 단일 익스텐트를 나타내는 비트맵이다.

- DCM(차등 변경 맵)
  마지막 BACKUP DATABASE 문 이후에 변경된 익스텐트를 추적한다. 익스텐트 비트가 1인 경우 수정, 0인경우 수정되지 않았음
  
  차등 백업의 경우 DCM 페이지만 읽고도 어떤 익스텐트가 수정되었는지 알 수 있다. 이를 통해 차등 백업이 검색해야 하는 페이지의 수가 상당히 줄어든다.
  
- BCM(대량 변경 맵)
  마지막 BACKUP LOG 문 이후 대량 로그 작업데 의해 수정된 범위를 추적한다. 익스텐트 비트가 1인 경우 익스텐트는 마지막 BACKUP LOG 문 다음에 수정되었고 0이면 수정되지 않았음.
  
  BCM 페이지가 모든 데이터베이스에 표시되더라도 데이터베이스가 대량 로그 복구 모델을 사용할 때만 적절하다. 이러한 복구 모델에서 BACKUP LOG가 수행되면 백업 프로세스는 수정된 익스텐트의 BCM을 검색하고 이런 익스텐트를 로그 백업에 포함시킨다.
  
DCM 페이지와 BCM 페이지 사이의 간격은 GAM 페이지와 SGAM 페이지의 간격인 64,000개의 익스텐트와 동일하다. DCM 및 BCM 페이지는 다음과 같이 물리적 파일의 GAM 및 SGAM 페이지 뒤에 있다.

![특수 페이지의 간격 분포를 보여 주는 다이어그램](https://learn.microsoft.com/ko-kr/sql/relational-databases/media/pages-and-extents-architecture-guide/special-page-order.svg?view=sql-server-ver16)

# 페이지 읽기
논리 읽기 : 버퍼 캐시에서 페이지를 요청할 때마다 발생
물리 읽기 : 디스크의 페이지를 캐시로 복사

데이터베이스 엔진 인스턴스 -> 읽기 요청 -> 관계형 엔진 -> 스토리지 엔진
관계형 엔진은 테이블 검색, 인덱스 검색 또는 키 사용 읽기와 같은 가장 효과적인 액세스 방법을 결정한다
스토리지 엔진은 읽기 패턴을 결정하고 최적화한다.
일괄 처리를 실행하는 스레드는 읽기 일정을 계획한다.

## 미리 읽기
데이터베이스 엔진은 Read-Ahead라는 성능 최적화 매커니즘을 지원한다. Read-Ahead는 쿼리 실행 계획을 수행하는데 필요한 데이터 및 인덱스 페이지를 예상하고 페이지가 쿼리에서 실제로 사용되기 전에 해당 페이지를 버퍼 캐시로 가져온다. 이렇게 하면 계산과 I/O가 동시에 수행되어 CPU와 디스크를 모두 충분히 활용할 수 있다.

미리 읽기 매커니즘을 사용하면 데이터베이스 엔진이 한 파일에서 최대 64개의 연속 페이지를 읽을 수 있다. 읽기는 버퍼 캐시에서 연속되지 않은 적절한 수의 버퍼에 대해 단일 분산 수집 읽기로 수행된다. 버퍼 캐시에 이미 존재하는 페이지가 있을 경우 읽기가 완료된 이후 읽기에서 전달받은 페이지는 버려진다. 

미리 읽기에는 데이터 페이지 읽기와 인덱스 페이지 읽기가 있다.

### 데이터 페이지 읽기
데이터 페이지를 읽는 데 사용되는 테이블 검사는 데이터베이스 엔진에서 매우 효율적이다. IAM을 토대로 디스크에서 읽어야하는 정렬된 디스크 주소 목룍을 작성해 대형 순차 읽기로 I/O를 최적화할 수 있다.

### 인덱스 페이지 읽기
스토리지 엔진은 리프 수준 위의 중간 인덱스 페이지에 있는 정보를 사용하여 키를 포함하는 페이지의 직렬 미리 읽기를 예약한다. 그렇다고 중간 인덱스 페이지가 커버하는 모든 범위를 검색하지는 않고 읽어야하는 리프 페이지 목록을 작성한다. 그런 다음 스토리지 엔진은 키 순서대로 모든 읽기를 예약한다

## 고급 검색
SQL Server Enterprise의 검색기능은 여러 태스크에서 전체 테이블 검색을 공유할 수 있다. Transact-SQL문의 실행 계획에 테이블의 데이터 페이지 검색이 필요하고 미리 실행되고 있던 쿼리의 실행 계획을 검사하여 같은 테이블을 검색하는 것을 감지하면 미리 읽고 있던 쿼리의 현재 페이지부터의 읽기 결과를 함께 전달 받는다. 하지만 나중에 실행된 쿼리는 다른 쿼리로부터 전달받은 그 페이지까지 다시 읽어 와야한다.

이런 방식으로 원하는 수만큼 검색을 결합할 수 있다. 이 매커니즘은 ORDER BY 절 없이 SELECT 문에서 반환된 결과의 순서를 보장할 수 없기 때문에 회전목마 검색이라고도 한다.

고급 검색을 사용하지 않는 경우 각 사용자는 버퍼 공간을 최대한 사용하려고 하며 이로 인해 디스크 충돌 경합이 발생한다. 그러면 같은 페이지를 여러 사용자가 한 번에 읽고 공유하는 대신 각 사용자가 한 번씩 읽게 되므로 성능이 저하되고 리소스 처리 시간이 소모된다.


# 페이지 쓰기
논리적 쓰기 : 버퍼 캐시에 있는 페이지의 데이터가 수정될 때 발생
물리적 쓰기 : 페이지를 버퍼 캐시에서 디스크로 쓸 때 발생

페이지가 버퍼 캐시에서 수정될 때 페이지는 디스크에 바로 기록되지 않고 더티 페이지로 기록된다. 즉, 페이지는 물리적으로 디스크에 기록되기 전에 두 개 이상의 논리적 쓰기를 수행할 수 있다. 각 논리적 쓰기의 경우 트랜잭션 로그 레코드는 수정 사항을 기록하는 로그 캐시에 삽입된다. 로그 레코드는 더티 페이지가 버퍼 캐시에서 디스크로 쓰여지기 전에 디스크에 쓰여져야한다. SQL Server는 연결된 로그 레코드가 디스크에 작성되기 전에 더티 페이지 작성을 방지하는 미리 쓰기 로깅이라는 기술을 사용한다.

