## 해시 파티션
### 정의
해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법

### 조건
해시 파티션의 파티션 키는 항상 정수 타입의 칼럼이거나 정수를 반환하는 표현식만 사용될 수 있다.

### 용도
- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때.

### 파티션 분리 원리
특정 파티션 키 값을 테이블의 파티션 개수로 `MOD`연산한 결괏값에 의해 각 레코드가 저장될 파티션을 결정한다

### 파티션 분리 및 병합
파티션의 개수는 레코드를 각 파티션에 할당하는 알고리즘과 연관되기 때문에 파티션을 추가하거나 삭제하는 작업에는 테이블 전체적으로 레코드를 재분배하는 작업이 따른다.

#### 파티션 추가
INPLACE 알고리즘으로 실행된다 하더라도 테이블 리빌딩은 발생하며 테이블에 대한 읽기 잠금이 필요하다. 따라서 파티션을 추가하거나 생성하는 작업은 많은 부하를 발생시키며, 다른 트랜잭션에서 동일 테이블에 데이터를 변경하는 작업은 허용되지 않는다.

#### 파티션 삭제
해시나 키 파티션은 파티션 단위로 삭제하는 방법이 없다. 왜냐하면 파티션 개수에 따라 자동으로 재분배되는 방식이라 내부에 어떤 데이터가 들어가는지 관리자가 확신할 수 없기 때문이다.

#### 파티션 분할
파티션을 분할하는 기능은 없다

#### 해시 파티션 병합
2개 이상의 파티션을 하나의 파티션으로 통합하는 기능은 제공되지 않는다. 단지 파티션의 개수를 줄이는 것은 가능하다. 파티션의 개수를 줄이게 되면 테이블을 재구성하는 작업이 수행된다.

## 키 파티션
### 해시 파티션과의 차이
키 파티션은 해시 파티션과 사용법과 특성이 거의 같다. 해시 파티션은 해시 값을 계산하는 방법을 파티션 키나 표현식에 사용자가 명시하지만 키 파티션에서는 해시 값의 계산도 MySQL 서버가 수행한다. 

MySQL 서버는 선정된 파티션 키의 값을 MD5() 함수르 이용해 해시 값을 계산하고 그 값을 MOD 연산해서 데이터를 각 파티션에 분배한다.

### 주의사항 및 특이사항
- 키 파티션은 MySQL 서버가 내부적으로 MD5() 함수를 이용해 파티션하기 때문에 파티션 키가 반드시 정수 타입이 아니어도 된다.
- 프라이머리 키나 유니크 키를 구성하는 칼럼 중 일부만으로도 파티션할 수 있다.
- 유니크 키를 파티션 키로 사용할 때 해당 유니크 키는 반드시 NOT NULL이어야 한다
- 해시 파티션에 비해 파티션 간의 레코드를 더 균등하게 분할할 수 있기 때문에 키 파티션이 더 효율적이다.

## 리니어 해시 파티션/리니어 키 파티션
### 정의
해시 파티션이나 키 파티션은 새로운 파티션을 추가하거나 파티션의 개수를 줄인다면 전체 파티션에 저장된 레코드의 재분배 작업이 발생한다. 리니어 해시 파티션/리니어 키 파티션은 각 레코드 분배를 위해 "Power-of-two(2의 승수)" 알고리즘을 이용하며, 이 알고리즘은 파티션의 추가나 통합 시 다른 파티션에 미치는 영향을 최소화해준다.

### Powers-of-two 알고리즘
[참고 링크](https://dev.mysql.com/doc/refman/8.0/en/partitioning-linear-hash.html)
`expr`의 표현식이 주어지면, 리니어 해시를 사용할 때 레코드가 저장되는 파티션은 `num`파티션 중에서 파티션 번호 `N`이며, 여기서 `N`은 다음의 알고리즘에 따라 파생된다.

1. `num`보다 큰 다음 2의 승수를 찾는다. 이 값을 `V`라고 부르며 다음과 같이 계산된다
```
V = POWER(2, CEILING(LOG(2,num)))
```
(`num` 이 13이라고 가정하자. `LOG(2,13)`은 3.7004397181411 이 된다. `CEILING(3.7004397181411)`은 4이므로, `V=POWER(2,4)`는 16이 된다)
2. `N=F(column_list) & (v-1)`으로 `N`을 정의
3. `N >= num` 인 동안에
	- `V=V/2`로 `V`를 재설정
	- `N=N&(V-1)`로 `N`을 재설정

#### 예제
아래의 리니어 해시 파티션을 사용하고 6개의 파티션을 가지는 `t1`테이블을 가정하자
```
CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE) PARTITION BY LINEAR HASH( YEAR(col3) ) PARTITIONS 6;
```

이제 `t1`테이블이 2개의 레코드를 입력하는데 `col3`의 값이 '2003-04-14' 그리고 '1998-10-19'라고 가정하자. 

첫 번째 레코드의 파티션 번호는 아래와 같이 결정된다.

```
V = POWER(2, CEILING( LOG(2,6) )) = 8
N = YEAR('2003-04-14') & (8 - 1) 
	= 2003 & 7 
	= 3 

(3 >= 6 is FALSE: record stored in partition #3_)
```

두 번째 레코드의 파티션 번호는 아래와 같이 결정된다

```
V = 8 
N = YEAR('1998-10-19') & (8 - 1) 
	= 1998 & 7 
	= 6
	(6 >= 6 is TRUE: additional step required_)

N = 6 & ((8 / 2) - 1) 
	= 6 & 3
	= 2 
	
(2 >= 6 is FALSE: record stored in partition #2_)
```

### 리니어 해시 파티션/리니어 키 파티션의 추가
리니어 해시 파티션이나 리니어 키 파티션은 "Power-of-two" 알고리즘으로 레코드가 분배돼 있기 때문에 새로운 파티션을 추가할 때도 특정 파티션의 레코드만 재분배되면 된다.

### 리니어 해시 파티션/리니어 키 파티션의 통합
리니어 해시 파티션이나 리니어 키 파티션에서 여러 파티션을 하나의 파티션으로 통합하는 작업 또한 새로운 파티션을 추가할 때와 같이 일부 파티션에 대해서만 레코드 통합 작업이 필요하다.

### 리니어 해시 파티션/리니어 키 파티션 재분배
리니어 해시 파티션이나 리니어 키 파티션의 파티션이 추가가 될 경우, 특정 파티션의 레코드가 다시 재분배 된다.

#### 9개의 파티션에서 1개의 파티션 추가 시 프로세스
1. 파티션 1개 추가
2. `N`이 9가 나와 다시 `N`값을 구했던 파티션 번호 계산
	1. `N = 9 & (16 - 1) = 9`
	2. `N = 9 & (8 - 1) = 1`
3. 1번 파티션 재분배


## 파티션 테이블의 쿼리 성능
MySQL에서 파티션된 테이블을 조회할 경우 모든 파티션 테이블의 파일을 연 뒤 하나하나 메모리에 올리며 조회하게 된다. MySQL은 버퍼 풀에 올라가있는 인덱스부터 조회하기 때문에 소수의 파티션을 자주 쓰는 경우라면 효율적으로 사용할 수 있을 것이다. 하지만 모든 파티션을 균등하게 사용하는 경우에는 오버헤드가 심해지기만 할 것이다. 대용량 테이블을 다른 MySQL 서버에 샤딩한다면 매우 효율적일 것이지만 MySQL 파티셔닝은 샤딩이 아니다. 따라서 파티션을 사용할 때는 반드시 파티션 프루닝이 얼마나 도움이 될지를 먼저 예측해보고 응용 프로그램에 적용하자