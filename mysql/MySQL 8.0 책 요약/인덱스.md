# 인덱스

# 인덱스란?

인덱스는 탐색 시간을 줄여주는 데이터 파일로서 RDBMS에서 가장 중요한 개념이다.

인덱스를 설명하는 가장 간단한 방법은 사전을 예로 드는 것이다. 사전은 ㄱ부터 ㅎ까지 순서대로 단어가 정렬되어있고 같은 카테고리 안에서도 정해진 정렬 규칙을 토대로 정렬되어있다. 규칙을 인지하고 있는 사용자들은 찾고자하는 단어를 정렬 규칙에 맞춰 더 빠른 속도로 찾게된다. 인덱스도 사전과 마찬가지로 특정 규칙에 의해 정렬되어있다.

인덱스는 기준이 되는 column을 key값으로, 해당 레코드가 저장된 디스크 주소를 value 값으로 가지고 있다. key는 특정 규칙으로 정렬되어있고 value는 key에 의해 특정된다. 인덱스에서 key는 항상 정렬되어있기 때문에 레코드를 조회할 때는 아주 빠른 속도를 보여준다.

  

---

  

(id) primary index를 가지는 1000000 row table에서 89999 row select (약 9%)

  

index를 사용하지 않는 경우 : actual time=5.043..133.817

  

```

-> Filter: (index_speed.ni_id between 10000 and 99999) (cost=100348.45 rows=110997) (actual time=5.043..133.817 rows=90000 loops=1)

-> Table scan on index_speed (cost=100348.45 rows=999077) (actual time=0.048..106.234 rows=1000000 loops=1)

```

  

index를 사용할 경우 : actual time=0.020..26.822
  

```

-> Filter: (index_speed.id between 10000 and 99999) (cost=35110.61 rows=175374) (actual time=0.020..26.822 rows=90000 loops=1)

-> Covering index range scan on index_speed using PRIMARY over (10000 <= id <= 99999) (cost=35110.61 rows=175374) (actual time=0.018..20.554 rows=90000 loops=1)

```

  

---

  

하지만 데이터를 추가하거나 변경, 삭제할 경우 인덱스를 재정렬 해야하기 때문에 느려지게 된다.

  

따라서 인덱스는 데이터 추가, 변경, 삭제의 성능을 희생하고 조회의 성능을 높이는 기능이다.

  

## 인덱스의 구분

  

**역할별**

  

- Primary key(index)

- 테이블 내에서 하나의 레코드를 특정시킬 수 있는 column

- NULL값을 허용하지 않으며 중복을 허용하지 않음

- Secondary key(index)

- Primary key를 제외한 key들은 모두 Secondary key 이다

- Unique index는 Primary key와 성격이 비슷하고 Primary key를 대체해서 사용할 수도 있다고 해서 대체 키라고도 하는데 별도로 분류하기도 하고 Secondary key 에 포함시키기도 한다

  

**알고리즘별**

  

- B-Tree index

- 칼럼의 값을 변형시키지 않고 인덱싱

- Hash index

- 칼럼의 값을 해쉬값으로 변형시켜 인덱싱

- 값을 변형시키기 때문에 전방일치 같은 값의 일부분을 사용하는 검색은 사용할 수 없음

- Fractal-Tree index

- Merge-Tree index

  

**데이터 중복 여부**

  

key값으로 단 하나의 레코드가 식별되는 것과 여러 레코드가 식별되는 것은 아주 큰 차이가 있다.

  

- Unique index

- Non-Unique index

  

# B-Tree 인덱스

  

B-Tree는 Balanced Tree의 약자로 internal node에 저장된 데이터의 개수가 동일하고 모든 leaf node의 depth가 동일하게 증감된다.

  

B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.
  

B-Tree 자료구조를 이용한 인덱스는 루트노드에서부터 리프노트까지 범위를 점점 좁혀나가는 방식으로 이루어져 있다. 루트노드는 인덱스 키값을 특정 규칙에 의해 대략적으로만 저장하고 있다.

  

storage engine에 따라 leaf node에 저장되는 value 값이 달라지는데, MyISAM의 경우 record가 저장된 주소값을 value로 갖고 있어 record에 직접 접근이 가능하다. 하지만 InnoDB의 경우 Primary key를 저장하고 있어 데이터 파일 내에서 해당 값으로 다시 한번 검색하여 record에 접근해야한다.

  

그렇다면 InnoDB가 Secondary index로 조회 시 더 느린 성능을 보이게 되는데, 왜 Primary key를 저장하게 될까?

  

InnoDB는 데이터를 Primary key값으로 정렬된 B+-Tree 구조의 인덱스 방식으로 저장하고 있기 때문이다. 따라서 B-Tree의 노드가 추가되거나 분기되는 것처럼 데이터가 변경될 때 마다 저장 위치가 변경될 수 있다. 이 때 Secondary index가 Primary key가 아닌 데이터 파일 주소를 가지고 있다면 데이터가 변경될 때 마다 인덱스에 저장된 주소 값도 변경해줘야 한다. 이런 오버헤드를 줄이고자 Secondary index는 데이터 파일 주소 대신 Primary key값을 가지고 있는 것이다.

  

### 인덱스 키 추가

  

데이터 변경이 느린 B-Tree의 특성상 테이블에 레코드를 추가하는 것 보다 더 많은 비용이 든다고 상정하게 된다. 테이블에 레코드를 추가하는 작업 비용을 1이라고 가정하면 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5 정도로 예측한다(물론 상황에 따라 다르겠지만). 중요한 것은 이 비용의 대부분이 메모리와 cpu에서 처리하는 시간이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간이라는 점이다.

  

MyISAM이나 MEMORY 스토리지 엔진은 INSERT문이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 반영하지만 InnoDB는 인덱스 키 추가 작업을 지연시켜 나중에 한번에 처리할 수 있다(체인지 버퍼).

  

### 인덱스 키 삭제 & 변경

  

인덱스 키 삭제&변경 또한 InnoDB 스토리지 엔진에서는 삭제 작업을 지연시켜 한번에 처리할 수 있다.

  

### 인덱스 키 검색

  

데이터 변경 성능을 희생하고 검색 성능을 높인 것이 B-Tree index이다.

  

인덱스를 검색하는 작업은 B-Tree의 루트노드로부터 리프노드까지 이동하면서 비교 작업을 하는데 이 과정을 트리 탐색이라고 한다. 인덱스 트리 탐색은 SELECT 뿐만 아니라 UPDATE, DELETE에서도 사용된다. B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. 부등호 비교조건도 가능하지만 후치 일치의 경우에는 사용할 수 없다. 중요한 사실은 키 값에 변형이 가해진 후 비교되는 경우에는 B-Tree의 빠른 검색 기능을 사용할 수 없다.

  

InnoDB 스토리지 엔진에서 인덱스는 레코드 잠금이나 넥스트 키락에서도 사용되는데, UPDATE나 DELETE에 해당되는 레코드가 사용할 수 있는 인덱스에 해당하는 레코드를 모두 잠근다. 만약 레코드가 사용할 수 있는 인덱스가 없다면 불필요하게 테이블의 모든 레코드를 잠그고 UPDATE를 진행한다.

  

## B-Tree 인덱스 사용에 영향을 미치는 요소

  

### 인덱스 키 값의 크기

  

InnoDB 스토리지 엔진은 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다. 메모리의 버퍼 풀에서 데이터를 버퍼링하는 기본단위이기도 하다. B-Tree 인덱스의 모든 노드는 페이지로 이루어져 있다.

  

인덱스 페이지의 크기는 innodb_page_size 시스템 변수를 통해 4~64KB의 범위에서 선택할 수 있는데, 기본값은 16KB이다. 인덱스는 key와 value로 이루어져 있으므로 페이지 하나에 저장할 수 있는 키의 개수는 대략 **(innodb_page_size * 1024 / key size(Byte) + value size(Byte))** 개 이다.

  

- innodb_page_size가 16이고 key size가 16Byte, value size가 12Byte 라면 16*1024/(16+12) = 585개를 저장할 수 있다.

- innodb_page_size가 16이고 key size가 32Byte, value size가 12Byte 라면 16*1024/(32+12) = 372개를 저장할 수 있다.

  

만약 SELECT 구문이 500개의 ROW를 읽어야 한다면 전자에 비해 후자는 페이지를 디스크로부터 최소한 2번 이상 읽어야 하기 때문에 더 느려진다.

또한 인덱스 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것을 의미한다. 하지만 메모리 공간에 버퍼 풀의 영역은 한정되어 있기 때문에 인덱스 크기가 커지면 메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다.

  

### B-Tree 깊이
B-Tree의  깊이는 중요하지만 직접 제어할 방법은 없다.

innodb_page_size가 16이고 key size가 16Byte, value size가 12Byte, B-Tree의 depth가 3일 경우 저장할 수 있는 키 값의 개수 : 585 \* 585 \* 585 개  
innodb_page_size가 16이고 key size가 32Byte, value size가 12Byte, B-Tree의 depth가 3일 경우 저장할 수 있는 키 값의 개수 : 372 \* 372 \* 372 개

**결론적으로 인덱스 키 값의 크기가 증가하면 페이지에 저장할 수 있는 인덱스 키 개수가 줄어들고, 인덱스 Tree의 깊이가 깊어져 탐색 시간이 늘어나게 된다.**


### 선택도(기수성) / Selectivity(Cardinality)
선택도와 기수성은 같은 의미로 사용되며 인덱스 키 값 중 유니크한 키의 개수를 의미한다. 인덱스를 만들 때 기수성이 높은 컬럼을 선택하는 것이 좋은 성능을 보인다.

** 정렬이나 그루핑의 경우 기수성이 좋지 않더라도 인덱스를 만드는 것이 좋은 경우가 있어 적절한 인덱스 생성이 중요하다 **

> 10000개의 record가 저장된 테이블에서 country 칼럼으로만 인덱스가 생성됐다고 했을 때, 단 하나의 row를 조회한다면 Cardinality에 따라 인덱스의 효율이 달라진다
> 1. Cardinality가 10일 경우 | 하나의 record에 접근하기 위해 1000개의 record에 접근하게 됨
> 2. Cardinality가 1000일 경우 | 하나의 record에 접근하기 위해 10개의 record에 접근하게 됨

### 읽어야 하는 레코드의 건수
어떤 나라에 여행을 간다고 할 때 당연히 직통 비행기를 타는 것 보다 경유기를 타는 것이 느리다. 인덱스는 레코드에 접근하기 위한 경유지 역할을 하기 때문에 직접 접근하는 것 보다 더 느릴 수 밖에 없다.   
인덱스를 통해 레코드 1건을 읽는 것이 디스크에서 직접 1건을 접근하는 것 보다 4~5배 비용이 더 드는 작업으로 예측되기 때문에 **전체 테이블 레코드의 20~25% 이상의 레코드를 읽어야한다면 인덱스보다 풀 테이블 스캔을 하는 것이 더 효율적이다**.

#### 예시
1,000,000건의 레코드가 저장된 테이블에서
인덱스가 생성되어있는 ten_alphabet 컬럼에 접근한다고 하자
ten_alphabet은 'A'부터 'J'까지 10개의 알파벳이 저장되어 있는데, 'A'는 전체의 82%를 차지하고 있고, 나머지 알파벳이 동일한 파이를 나눠갖고 있다.


##### innodb(no histogram)
`select * from tb where ten_alphabet >= 'A'`
위의 쿼리는 모든 레코드를 조회하는 쿼리이기 때문에 실행 계획에서도 full table scan을 선택했다

`select * from tb where ten_alphabet >= 'B'`
위의 쿼리는 전체의 18%의 레코드를 조회하는 쿼리인데, full table scan을 선택했다.

`select * from tb where ten_alphabet >= 'C'`
하지만 전체의 16%를 조회하는 쿼리는 index range scan을 선택했다. 풀 테이블 스캔하는 것 보다 인덱스를 경유하는 것이 더 빠르다고 예상한 것이다.

##### myisam
myisam에서 인덱스는 primary key를 저장하지 않고 레코드의 주소를 직접 저장한다.
따라서 Ramdom I/O가 필연적으로 발생하게 되어 clustered index를 사용할 때 보다 인덱스를 경유할 때 높은 코스트가 책정될 것이다.
또한 myisam의 경우 histogram을 사용하지 못하기 때문에 인덱스를 랜덤 조회하여 추측하거나 unique값의 개수를 통해 조회할 record 개수를 추측하게 될텐데, 이는 효율적이지 못한 실행계획을 수립할 수 있다.

`select * from tb where ten_alphabet >= 'C'`
innodb에서 index range scan을 선택했지만, myisam에선 full table scan을 선택했다.

`select * from tb where ten_alphabet >= 'H'`
myisam에선 전체의 6%를 조회할 때 index range scan을 선택했다.

##### innodb(with histogram)
**histogram을 사용전과 같은 결과를 보였다**

index된 칼럼을 조건으로 활용하는 경우 별도의 힌트를 주지 않는 한 히스토그램을 사용하지 않고 index dive를 하기 때문이다. index dive는 직접 인덱스에 접근하는 것이기 때문에 더 정확한 결과를 얻을 수 있다.


## B-Tree 인덱스를 통한 데이터 읽기
### 인덱스 레인지 스캔
인덱스 레인지 스캔은 인덱스의 접근 방법 중 가장 대표적인 접근 방식이다
인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다. 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현한다.

#### 조회할 칼럼이 인덱스에 포함되있을 경우
읽기를 시작해야하는 위치를 찾으면 그때부터 리프노드를 순차적으로 탐색하기만 하면 된다.

#### 조회할 칼럼이 인덱스에 포함되어 있지 않을 경우
읽기를 시작해야하는 위치를 찾고 그때부터 리프노드를 순차적으로 탐색하면서 value값으로 가지고 있는 primary key 값으로 실제 레코드에 접근한다.

#### 인덱스 레인지 스캔의 정렬
innodb에서 인덱스는 항상 인덱스 키 값으로 항상 정렬되어 있으므로 인덱스 키 값을 통해 데이터를 조회할 경우 항상 정순 또는 역순으로 정렬된 상태의 레코드를 가져오게 된다.

#### innodb와 myisam
또 한가지 중요한 점은 innodb와 MyISAM이 다른 방식의 데이터 접근을 보여준다는 것이다. innodb는 clustered index를 사용하고 있기 때문에 데이터를 Primary key가 key인 B+Tree 형태로 저장한다. 우리가 잘 알고 있는 인덱스와 같은 형태를 띄고 있지만 모든 데이터를 저장하고 있다는 점에서 경유지 역할을 해야하는 인덱스와는 다르다.

myisam에서는 인덱스의 value값이 데이터의 주소값이기 때문에 인덱스 레인지 스캔을 할 때 **레코드 한 건 단위로 Ramdom I/O가 발생**한다. 따라서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다.

### 인덱스 풀 스캔
**인덱스를 사용하지만 인덱스의 처음부터 끝까지 모두 읽는 방식**

#### 사용 조건
대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다. (A,B,C)칼럼의 순서로 인덱스가 만들어져 있을 때, 조건절에 B나 C칼럼으로 검색할 때 풀 스캔이 사용된다.

일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 인덱스만 읽는 것이 효율적이다. 따라서 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있으면 이 방식이 사용된다.

하지만 착각해서는 안되는것이, 인덱스를 사용한다고 해서 효율적인 것이 아니다. 인덱스를 처음부터 끝까지 스캔하기 때문에 인덱스 풀 스캔은 인덱스 레인지 스캔이나 루스 인덱스 스캔에 비해서는 효율적이지 않다. 

### 루스 인덱스 스캔
> 루스 인덱스  스캔은 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다

#### 사용처
group by 또는 집합 함수 가운데 max() 또는 min() 함수에 대해 최적화를 하는 경우에 사용됨

#### 예시
(category_no, user_no)의 인덱스에서 `group by category_no` 으로 그룹핑 하고 `max(user_no)` 를 조회하는 경우 category_no에 대한 모든 user_no를 스캔할 필요 없이 이미 정렬되어있는 인덱스에서 category_no별 가장 최상단, 역순으로 정렬되어 있으면 최하단의 인덱스를 선택하는 것이 효율적이다.

### 인덱스 스킵 스캔
(gender, birth_date) 인덱스가 있을 때, gender에 대한 비교 조건이 없으면 인덱스를 사용할 수 없었다. MySQL 8.0 부터는 옵티마이저가 gender 칼럼을 건너뛰어서 birth_date 칼럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입됐다.

#### 동작 방식
(gender, birth_date) 인덱스를 사용할 때, birth_date에 대한 조건문만 걸었다고 가정하자.

`select gender, birth_date from tb where birth_date >= '2020-01-01'`

이 때 MySQL 옵티마이저는 gender 칼럼의 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다

`select gender, birth_date from tb where gender='M' and birth_date >= '2020-01-01'`
`select gender, birth_date from tb where gender='F' and birth_date >= '2020-01-01'`

#### 단점
- WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)

## 다중 칼럼 인덱스
여러개의 칼럼으로 이루어진 인덱스의 경우, 왼쪽에 위치한 컬럼 부터 정렬된다. 즉, (alpabet, number) 인덱스의 경우 (a,0),(a,1),(a,2)...(b,0),(b,1)... 순으로 진행될 것이다. SQL문법을 아는 사람이면 group by 구문에 여러 컬럼을 적용시켰을 때 정렬 방법과 같다고 생각하면 된다.

인덱스를 구성하는 칼럼의 순서에 따라 접근 순서가 달라지고 따라서 실행 계획이 달라지기 때문에 **인덱스의 칼럼 순서는 아주 중요하다**


## B-Tree 인덱스의 정렬 및 스캔 방향
### 내림차순 인덱스
내림차순 인덱스의 중요성은 내림차순 조회를 많이 하게되는 환경에 의해 결정된다.

내림차순 인덱스는 말 그대로 내림차순으로 정렬되어있는 인덱스인데, 오름차순으로 조회하고 싶다면 인덱스를 역순으로 조회해야한다. 하지만 innodb에서 역순으로 조회하는 것은 성능이 떨어지기 때문에 보통 가장 많이 조회하는 순서인 내림차순으로 정렬한다.

#### 인덱스 역순 스캔의 단점
##### 원인
- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

## B-Tree 인덱스의 가용성과 효율성

### 비교 조건의 종류와 효율성

>다중 칼럼 인덱스에서 각 칼럼의 사용된 조건이 동등 비교인지 아니면 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.

동등 비교와 범위 비교를 혼용할 경우, 인덱스의 칼럼 순서에 따라 효율성이 달라진다

`select * from tb where dept_no='d002' and emp_no >= 10114;`

위 쿼리를 실행할 때 사용될 인덱스의 종류가 두 개가 있다고 가정하자

A : `INDEX(dept_no,emp_no)`
B : `INDEX(emp_no,dept_no)`

A 인덱스일 경우, dept_no가 `d002` 로 시작하는 인덱스 레코드 위치를 찾고, `emp_no` 가 10114인 위치부터 범위 탐색을 하게 된다.
B 인덱스일 경우, `emp_no >= 10114` 인 인덱스 레코드 위치를 찾고 범위 탐색을 하면서 `dept_no` 가 `d002` 인지 하나하나 비교한다.

 