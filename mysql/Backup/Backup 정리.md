> 복제는 백업이 아니다

MySQL은 #GTID 를 활용한 복제 기술을 가지고 있지만 복제 기술은 #고가용성 을 위한 것이지, 데이터 복구를 위한 기술은 아니다. 복제를 통해 백업 및 복구를 할 수는 있지만, Master Node와 Slave Node의 데이터 불일치가 발생할 수 있고, 관리자나 사용자의 실수로 인한 백업이 어렵다. 또한 빠른 insert 작업을 위해 logging을 끈 후 발생하는 이슈나, 하드웨어 장애, 관리자의 실수 등 데이터를 복구해야 할 상황이 발생하기 때문에 백업은 필수이다.

# 백업 계획
## RPO와 RTO
#RPO 는 복구 시점 목표로 복구를 진행한 이후 어느 시점으로 돌아가는지를 말한다.

#RTO 는 복구 시간 목표로 장애를 복구하는데 드는 시간을 말한다.

따라서, RPO와 RTO가 적을 수록 장애 대응이 좋다고 볼 수 있다.

이를 위해서 각각의 서비스에 대한 RPO와 RTO를 설정하고, 이에 대한 백업 정책과 백업 절차를 미리 마련하는 것이 중요하다.

또한 백업 계획 시 고려해야 할 성능 요소로는 백업 시간, 백업 부하, 복구 시간이 있다. 이 중 가장 큰 트레이드 오프가 백업 시간과 백업 부하인데, 서버의 자원 소모량이나 시간적인 상황에 맞춰 잘 선택하여 진행해야 한다.

# 백업의 종류
## 온라인 백업과 오프라인 백업
온라인 백업은 서버를 중단시키지 않고 백업을 진행하는 것이다. 당연히 DB를 재시작하는데 드는 부하는 없고 서비스를 유지시키면서 백업을 진행할 수 있다. 

하지만 백업을 하는 동안 데이터가 수정될 수 있고, 백업을 하는 동안 서버나 어플리케이션에 부하가 걸릴 수 있기 때문에 가능한 DB를 종료하고 백업을 만드는 것이 낫다.

## 논리적 백업과 원시 백업
논리적 백업은 명령문 실행을 통해 데이터를 복구하는 것을 말한다. 논리적 백업을 도와주는 도구로는 #mysqldump 등이 있다. [[mysqldump 백업]]


명령문으로 이루어져 있기 때문에 데이터를 복원하지 않은 상태에서 데이터를 검사할 수 있고, 다른 시스템에서 네트워크를 통해 백업 및 복원할 수 있다.

하지만 논리적 백업은 서버에서 생성하는 작업을 수행하기 때문에 더 많은 자원을 소모하게 되고, 데이터 복원에 사용될 때도 명령을 수행하여 데이터를 로드하는 비용이 크다.

원시 백업은 원하는 파일을 다른 곳에 옮기기만 하면 된다. 그리고 논리적 백업과 비교하면 명령문을 실행하거나 인덱스를 생성할 필요가 없어 더 빠를 수 있다.

하지만 원시 파일은 논리적 백업의 덤프 파일보다 훨씬 큰 경우가 많고, 원시 백업은 오류가 발생하기 쉽다.

원시 백업은 일반적으로 더 쉽고 효율적이지만 장기 보존이나 법적 요구 사항에 원시 백업을 사용해서는 안된다. 최소한 주기적으로 논리적 백업을 수행해야 한다.

## 증분 백업과 차등 백업
차등 백업은 '전체 백업' 이후의 변경된 데이터에 대한 부분 백업이고, 증분 백업은 '전체 백업을 포함한 모든 백업' 이후의 변경된 데이터에 대한 부분 백업이다.

예를 들어 일요일에 전체 백업을 한 뒤 월요일에 차등 백업을 진행한다. 화요일에는 일요일 이후의 데이터를 차등 백업할 수 있고 월요일 이후의 데이터를 증분 백업할 수 있다.

전체 데이터를 백업하는 전체 백업에 비해 변경된 데이터만 저장하기 때문에 서버의 오버헤드, 백업 시간 및 백업 공간의 절약을 기대할 수 있다.

하지만 이와 무관하게 전체 백업이 필요하다. 부분 백업이 많아질 수록 복구하기 어려위지기 때문이다.

# 참고
- MySQL 성능 최적화(O'Reilly)